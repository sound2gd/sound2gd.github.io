<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>JVM拾遗(3): 类装载机制 | Chris的博客</title><meta property="og:title" content="JVM拾遗(3): 类装载机制 - Chris的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-02-12T17:39:41+08:00"><meta property="article:modified_time" content="2019-02-12T17:39:41+08:00"><meta name=Keywords content="golang,go语言,sound2gd,Chris,java,jvm,android,博客,项目管理,金融科技,clojure,软件架构,公众号,小程序"><meta name=description content="JVM拾遗(3): 类装载机制"><meta name=author content="Chris Wang"><meta property="og:url" content="http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%973-%E7%B1%BB%E8%A3%85%E8%BD%BD%E6%9C%BA%E5%88%B6/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=http://sound2gd.wang/>Chris的博客</a><p class=description>专注于Jvm(openjdk)、Go语言(golang)、效率工具、项目管理、软件架构、金融科技</p></div><div><nav id=nav-menu class=clearfix><a class=current href=http://sound2gd.wang/>首页</a>
<a href=http://sound2gd.wang/archives/ title=归档>归档</a>
<a href=http://sound2gd.wang/life/ title=学习>学习</a>
<a href=http://sound2gd.wang/about/ title=关于>关于</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JVM拾遗(3): 类装载机制</h1></header><date class="post-meta meta-date">2019年2月12日</date><div class=post-content><p>上一篇我们了解了class文件结构, 那么JVM如何使用编译好的class二进制文件?</p><p><strong>简言之: JVM会读取<code>.class</code>文件并加载和初始化到方法区</strong>, 之后才能被后续程序使用.
同时该过程还需要满足一些要求:</p><ul><li>加载的class文件不能影响虚拟机的稳定性, 也就是class文件要正确合法<ul><li>java的rt.jar里定义的类,如java.lang.Object, 不能被替换</li><li>class文件里的各个符号引用要合法</li></ul></li><li>允许运行时添加功能, 如各种分析工具包(arthas)等</li></ul><p>JVM是解释执行字节码的，不像c/c++那样编译的时候静态链接完了, 是在运行时期动态链接的。</p><h1 id=1-类装载器classloader>1. 类装载器(ClassLoader)</h1><h2 id=11-加载load>1.1 加载(Load)</h2><blockquote><p>Loading is the process of finding the binary representation of a class or interface type with a particular name and creating a class or interface from that binary representation</p></blockquote><p>这是一段jvm8规范, 表示<code>装载</code>的过程就是<strong>通过一个特定的名字(类全名)来找到并获取描述此类的二进制表示的过程</strong>, 装载器(ClassLoader)用来完成装载过程.</p><p>虚拟机规范并没有规定从哪里装载，所以可以从<code>网络上</code>, <code>zip包里</code>, <code>class文件里</code>等各个地方装载class文件.</p><h2 id=12-双亲委派模型>1.2 双亲委派模型</h2><p>JVM划分了3个层次的<code>ClassLoader</code>, 分别是:</p><ol><li><code>启动类加载器BootstrapClassLoader</code>: 加载JDK提供的各个类，也就是rt.jar里的各个类, 启动类加载器无法被Java程序直接使用</li><li><code>扩展类加载器ExtensionClassLoader</code>: 加载<code>${JavaHome}/lib/ext</code>下的类库, 可以被开发者使用</li><li><code>应用类加载器ApplicationClassLoader</code>: 这个是开发者用的最多的, 它复杂加载<code>ClassPath</code>上指定的类库, 如果应用程序没有指定类加载器，默认就是用这个类加载器加载的。</li></ol><p>类加载器之间是有父子关系的，上面的类加载器的关系是:</p><p><a data-fancybox=gallery href="http://img.sound2gd.wang/2019/02/12/20190212230804.png?watermark/2/text/U291bmQyZ2TnmoTljZrlrqIK/font/5Lu_5a6L/fontsize/320/fill/IzEzMjRFQg==/dissolve/60/gravity/SouthEast/dx/0/dy/-10"><img class=mx-auto alt src="http://img.sound2gd.wang/2019/02/12/20190212230804.png?watermark/2/text/U291bmQyZ2TnmoTljZrlrqIK/font/5Lu_5a6L/fontsize/320/fill/IzEzMjRFQg==/dissolve/60/gravity/SouthEast/dx/0/dy/-10"></a></p><p>这种层次关系称为<code>双亲委派模型</code>，如果一个ClassLoader收到了装载类的请求,它的工作过程是:</p><ol><li>先交给父ClassLoader加载, 如果父在加载器加载完成，直接返回class</li><li>如果父ClassLoader不能加载，则自己负责加载</li></ol><p>所以无论哪个ClassLoader加载<code>java.lang.Object</code>, 得到的都是<code>BootstrapClassLoader</code>加载出来的.</p><p>用户如果自定义<code>ClassLoader</code>, 继承的都是<code>java.lang.ClassLoader</code>,
据说最初ClassLoader设计出来是为了满足JavaApplet的需求, 由于笔者没有类似经验，就留给读者自己研究了.</p><h4 id=违背双亲委派模型>违背双亲委派模型</h4><ol><li>双亲委派模型自JDK1.2以后才出现，而<code>java.lang.ClassLoader</code>在1.0就已经出现，所以JDK不得不兼容新加了一个findClass()方法, 1.2以后一定不推荐直接写loadClass方法, 而是推荐用findClass,这样可以保证新写出来的类加载器是符合双亲委派机制的</li><li>由于子类加载器会先将类交给父类加载器加载，解决了基础类的统一问题。如果基础类要调用用户类的代码，就无法作为。JDK为了满足这个需求(如在JNDI中)，引入了Thread Context ClassLoader, 这个类加载器可以通过<code>setContextClassLoader</code>进行设置, JDBC用这个类加载器去加载SPI代码, 实际上违背了双亲委派机制.</li><li>OSGi模块化，导致用户自定义的类加载器是网状结构</li></ol><h2 id=13-自定义classloader>1.3 自定义ClassLoader</h2><p>自定义ClassLoader只需要继承<code>java.lang.ClassLoader</code>并且重写<code>findClass或者loadClass</code>方法就行了, 后面还会讲.</p><p><strong>一个类由类名和类加载器唯一标识</strong>, 每个类加载器都有自己的独立的命名空间.</p><p>及时两个类来自同一个class文件，被同一个JVM装载，只要加载它们的ClassLoader不一样，则这两个类不相等， 可以在同一个JVM里共存.</p><h1 id=2-类装载过程>2. 类装载过程</h1><p>根据jvm8规范,类被类装载器装载到虚拟机内存，到卸载出内存，中间要经历以下步骤:</p><ol><li>创建和加载(Creation And Loading)</li><li>链接(Linking)</li><li>初始化(Initialization)</li><li>绑定本地方法实现(Binding Native Method Implementations)</li></ol><h2 id=21-创建和加载>2.1 创建和加载</h2><p>这个阶段，虚拟机要完成3个事情:</p><ol><li>通过一个类的全限定名(Full Qualified Name)来获取定义此类的二进制流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象,作为方法区这个类的各种数据的访问入口</li></ol><p>以上规则不对数组类适用, 因为数组类本身不通过类加载器创建，而是通过JVM直接创建.数组类满足以下规则:</p><ul><li>如果数组的元素类型(Component Type, 也就是数组去掉一个维度的类型)是引用类型，递归加载这个类型,并且数组将在加载这个元素类型的类名称空间上被标识</li><li>如果数据的元素类型不是引用类型， 如int[], JVM会交给BootstrapClassLoader</li><li>数组类的可见性和它的元素类型一致</li></ul><h2 id=22-链接>2.2 链接</h2><p>链接阶段又包括<code>验证Verification</code>,<code>准备Preparation</code>, <code>解析Resolution</code>, <code>访问控制Access Control</code>, <code>覆盖Overriding</code>等步骤</p><h3 id=221-验证>2.2.1 验证</h3><p>这一阶段的目的是确保class文件的字节流中包含的信息符合JVM的规范，并且不会危害JVM自身的安全.</p><p>一般通过javac编译出来的class文件，都不会有任何问题，但是class文件可以通过各种途径生成, 比如从网络里读取，裸写二进制到文件等</p><p>验证阶段可能导致额外的类和接口被装载，验证的过程需要满足</p><ol><li>class文件格式验证: 魔数的正确性(0xCAFEBABE), 主次版本号满足要求,常量约束等</li><li>元数据验证: 对字节码描述的信息进行语义分析，比如这个类是否有父类，父类是否存在，是否继承了不该被继承的类(final**, 是否实现了要求实现的抽象方法等</li><li>字节码验证: 保证指令集是JVM规范里的，保证指令集的语义合法, 类型转换是有效的等</li><li>符号引用验证: 符号引用描述的类全限定名能不能找到对应的类, 引用的字段能不能访问等等</li></ol><p>上一节讲到class文件结构的属性表里有一个<code>StackMapTable</code>属性, 描述了方法体的所有基本块，只要检查这些状态的合法性就能判断字节码是否正确,能加速JVM的验证过程.
在1.6的HotSopt里能通过<code>-XX:UseSplitVerifier</code>来关闭这个优化</p><p>验证失败会抛出VerifyError, 终止类加载过程, 虚拟机退出</p><h3 id=222-准备>2.2.2 准备</h3><p>准备阶段是正式为类变量分配内存，并且设置类变量的初始值.</p><p><strong>分配的内存在方法区，也就是说类变量都在方法区里存着</strong></p><h3 id=223-解析>2.2.3 解析</h3><p>解析阶段JVM会将常量池内的符号引用替换为直接引用.直接引用一般就是一个直接指向目标的指针，相对偏移量或者间接定位到目标的句柄.</p><p>对同一个符号引用的解析，JVM会进行缓存，避免解析动作重复进行.除了<code>invokedynamic</code>指令，这个指令本身就是动态解析，只有程序运行到这的时候，解析动作才能进行.</p><p>解析动作主要针对类或接口，字段，类方法，接口方法，方法类型，句柄，调用点这7类符号引用。</p><h3 id=224-初始化>2.2.4 初始化</h3><p>类的初始化是最后一步，虚拟机规范里的访问控制和覆盖在前面几步已经交叉进行了.</p><p>到了初始化阶段才真正开始执行Java程序代码, 会执行类的初始化(不是调用类的构造函数)</p><p><code>&lt;cinit></code>: 类初始化，会搜集所有的static代码块合并并执行, 执行本类的<code>&lt;cinit></code>之前会先执行父类的. 如果类没有static代码，编译器可以不生成<code>&lt;cinit></code>, cinit是线程安全的.一个类型只会初始化一次.</p><h2 id=23-绑定本地方法实现>2.3 绑定本地方法实现</h2><p>这个过程是用来绑定c这样的native实现的, 虚拟机也没规定说要到最后再绑定.</p><h1 id=3-小结>3. 小结</h1><p>本次主要讲了JVM如何装载一个类, JVM是通过<code>Classloader</code>来装载类, <code>ClassLoader</code>通过<code>双亲委派机制</code>工作，并且每次装载都会经历<code>加载</code>,<code>链接</code>,<code>解析</code>这样的过程, 加载阶段会将二进制类表示在方法区, 链接阶段会验证class的合法性，并且初始化类变量, 但是不赋值(如int初始化为0).初始化阶段会触发一系列的类变量初始化工作和静态代码块执行工作, 这个阶段才真正开始执行java程序代码.</p><p>回过头看开头提出的需求，Java的动态性, 如热部署，动态编译JSP, 运行时增强类功能等, 通过类加载器动态加载类都可以实现:)</p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=http://sound2gd.wang/>Chris Wang</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%973-%E7%B1%BB%E8%A3%85%E8%BD%BD%E6%9C%BA%E5%88%B6/>http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%973-%E7%B1%BB%E8%A3%85%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/post/jvm%E6%8B%BE%E9%81%972-%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%9F%BA%E7%9F%B3%E4%B9%8Bclass%E8%A7%A3%E6%9E%90/>JVM拾遗(2): 平台无关性基石之Class解析</a></li><li><a href=/post/jvm%E6%8B%BE%E9%81%971-%E4%B8%87%E7%B1%B3%E9%AB%98%E7%A9%BA%E7%9C%8Bjvm/>JVM拾遗(1): 万米高空看JVM</a></li><li><a href=/post/java-nio%E5%88%86%E6%9E%9012-nio%E6%80%BB%E7%BB%93/>Java NIO分析(12): NIO总结</a></li><li><a href=/post/java-nio%E5%88%86%E6%9E%9011-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Anio%E7%9A%84%E6%94%AF%E6%8C%81/>Java NIO分析(11): 零拷贝技术以及NIO的支持</a></li><li><a href=/post/java-nio%E5%88%86%E6%9E%9010-jvm%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E6%94%B9%E8%BF%9B-directbuffer%E8%AF%A6%E8%A7%A3/>Java NIO分析(10): JVM堆外内存利用改进: DirectBuffer详解</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/java-jvm>JAVA JVM</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=sound2gd/blog-comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=http://sound2gd.wang/>Chris的博客 By Chris Wang</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>浙ICP备18046106号</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-N5MSKS0SN8"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N5MSKS0SN8",{anonymize_ip:!1})}</script></div><div id=secondary><section class=widget><form id=search action=http://sound2gd.wang/search/ method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=http://sound2gd.wang/>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=http://sound2gd.wang/post/bcd1a91c/ title=盘点rust写的好用命令行工具>盘点rust写的好用命令行工具</a></li><li><a href=http://sound2gd.wang/post/556f376d/ title=2022年Clojure技术栈推荐>2022年Clojure技术栈推荐</a></li><li><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%975-%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97/ title="JVM拾遗(5): 对象大小计算">JVM拾遗(5): 对象大小计算</a></li><li><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%974-java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ title="JVM拾遗(4): Java对象的创建及内存布局">JVM拾遗(4): Java对象的创建及内存布局</a></li><li><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%973-%E7%B1%BB%E8%A3%85%E8%BD%BD%E6%9C%BA%E5%88%B6/ title="JVM拾遗(3): 类装载机制">JVM拾遗(3): 类装载机制</a></li><li><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%972-%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%9F%BA%E7%9F%B3%E4%B9%8Bclass%E8%A7%A3%E6%9E%90/ title="JVM拾遗(2): 平台无关性基石之Class解析">JVM拾遗(2): 平台无关性基石之Class解析</a></li><li><a href=http://sound2gd.wang/post/jvm%E6%8B%BE%E9%81%971-%E4%B8%87%E7%B1%B3%E9%AB%98%E7%A9%BA%E7%9C%8Bjvm/ title="JVM拾遗(1): 万米高空看JVM">JVM拾遗(1): 万米高空看JVM</a></li><li><a href=http://sound2gd.wang/post/java-nio%E5%88%86%E6%9E%9012-nio%E6%80%BB%E7%BB%93/ title="Java NIO分析(12): NIO总结">Java NIO分析(12): NIO总结</a></li><li><a href=http://sound2gd.wang/post/java-nio%E5%88%86%E6%9E%9011-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Anio%E7%9A%84%E6%94%AF%E6%8C%81/ title="Java NIO分析(11): 零拷贝技术以及NIO的支持">Java NIO分析(11): 零拷贝技术以及NIO的支持</a></li><li><a href=http://sound2gd.wang/post/java-nio%E5%88%86%E6%9E%9010-jvm%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E6%94%B9%E8%BF%9B-directbuffer%E8%AF%A6%E8%A7%A3/ title="Java NIO分析(10): JVM堆外内存利用改进: DirectBuffer详解">Java NIO分析(10): JVM堆外内存利用改进: DirectBuffer详解</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=http://sound2gd.wang/categories/clojure/>Clojure (1)</a></li><li><a href=http://sound2gd.wang/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/>年终总结 (1)</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud><a href=http://sound2gd.wang/tags/2021/>2021</a>
<a href=http://sound2gd.wang/tags/clojure/>Clojure</a>
<a href=http://sound2gd.wang/tags/java-jvm/>JAVA JVM</a>
<a href=http://sound2gd.wang/tags/jvm-java/>JVM JAVA</a>
<a href=http://sound2gd.wang/tags/nio/>NIO</a>
<a href=http://sound2gd.wang/tags/nio-linux/>NIO Linux</a>
<a href=http://sound2gd.wang/tags/%E4%BA%BA%E7%94%9F/>人生</a>
<a href=http://sound2gd.wang/tags/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/>工程技术</a>
<a href=http://sound2gd.wang/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/>年终总结</a>
<a href=http://sound2gd.wang/tags/%E6%9D%82%E8%B0%88/>杂谈</a></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=http://sound2gd.wang/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>